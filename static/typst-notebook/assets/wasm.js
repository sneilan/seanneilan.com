const g=(t,e)=>e.some(n=>t instanceof n);let I,D;function C(){return I||(I=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function F(){return D||(D=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const E=new WeakMap,m=new WeakMap,M=new WeakMap,d=new WeakMap,b=new WeakMap;function S(t){const e=new Promise((n,r)=>{const s=()=>{t.removeEventListener("success",c),t.removeEventListener("error",i)},c=()=>{n(u(t.result)),s()},i=()=>{r(t.error),s()};t.addEventListener("success",c),t.addEventListener("error",i)});return e.then(n=>{n instanceof IDBCursor&&E.set(n,t)}).catch(()=>{}),b.set(e,t),e}function j(t){if(m.has(t))return;const e=new Promise((n,r)=>{const s=()=>{t.removeEventListener("complete",c),t.removeEventListener("error",i),t.removeEventListener("abort",i)},c=()=>{n(),s()},i=()=>{r(t.error||new DOMException("AbortError","AbortError")),s()};t.addEventListener("complete",c),t.addEventListener("error",i),t.addEventListener("abort",i)});m.set(t,e)}let y={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return m.get(t);if(e==="objectStoreNames")return t.objectStoreNames||M.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function A(t){y=t(y)}function O(t){return t===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...n){const r=t.call(l(this),e,...n);return M.set(r,e.sort?e.sort():[e]),u(r)}:F().includes(t)?function(...e){return t.apply(l(this),e),u(E.get(this))}:function(...e){return u(t.apply(l(this),e))}}function _(t){return typeof t=="function"?O(t):(t instanceof IDBTransaction&&j(t),g(t,C())?new Proxy(t,y):t)}function u(t){if(t instanceof IDBRequest)return S(t);if(d.has(t))return d.get(t);const e=_(t);return e!==t&&(d.set(t,e),b.set(e,t)),e}const l=t=>b.get(t),x=["get","getKey","getAll","getAllKeys","count"],W=["put","add","delete","clear"],h=new Map;function p(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(h.get(e))return h.get(e);const n=e.replace(/FromIndex$/,""),r=e!==n,s=W.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(s||x.includes(n)))return;const c=async function(i,...o){const f=this.transaction(i,s?"readwrite":"readonly");let a=f.store;return r&&(a=a.index(o.shift())),(await Promise.all([a[n](...o),s&&f.done]))[0]};return h.set(e,c),c}A(t=>({...t,get:(e,n,r)=>p(e,n)||t.get(e,n,r),has:(e,n)=>!!p(e,n)||t.has(e,n)}));class k{loadedFonts=new Set;fetcher=fetch;setFetcher(e){this.fetcher=e}async loadFonts(e,n){const r=new Function("m","return import(m)"),s=this.fetcher||=await async function(){const{fetchBuilder:o,FileSystemCache:f}=await r("node-fetch-cache"),a=new f({cacheDirectory:".cache/typst/fonts"}),L=o.withCache(a);return function(B,P){const T=setTimeout(()=>{console.warn("font fetching is stucking:",B)},15e3);return L(B,P).finally(()=>{clearTimeout(T)})}}(),c=n.filter(o=>o instanceof Uint8Array?!0:this.loadedFonts.has(o)?!1:(this.loadedFonts.add(o),!0)),i=await Promise.all(c.map(async o=>{if(o instanceof Uint8Array){await e.add_raw_font(o);return}return new Uint8Array(await(await s(o)).arrayBuffer())}));for(const o of i)o&&await e.add_raw_font(o)}async build(e,n,r){const s={ref:this,builder:n,hooks:r};for(const i of e?.beforeBuild??[])await i(void 0,s);return r.latelyBuild&&r.latelyBuild(s),await n.build()}}async function v(t,e,n,r){return await e.init(t?.getModule?.()),await new k().build(t,new n,r)}const N=Symbol.for("reflexo-obj");var w;(function(t){t[t.PIXEL_PER_PT=3]="PIXEL_PER_PT"})(w=w||(w={}));const R=t=>{let e=!1,n;return()=>e?n:(e=!0,n=t())};class K{wasmBin;initOnce;constructor(e){if(typeof e!="function")throw new Error("initFn is not a function");this.initOnce=R(async()=>{await e(this.wasmBin)})}async init(e){this.wasmBin=e,await this.initOnce()}}export{K as L,w as T,v as b,N as k};
